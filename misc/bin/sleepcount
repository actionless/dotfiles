#!/usr/bin/env python
import sys
import time
import datetime
from typing import List, Optional


def print_usage():
    print("@TODO: print usage")


# @TODO: use argparse
ARGS = sys.argv[1:]
DO_COUNTDOWN = False
if '-c' in ARGS:
    DO_COUNTDOWN = True
    ARGS.remove('-c')
if not ARGS:
    print_usage()
    sys.exit(1)

CURRENT_DATE = datetime.datetime.now()


def parse_exact_time(time_string: str) -> Optional[datetime.datetime]:
    result = None
    for format_string in ('%H:%M', '%H:%M:%S'):
        try:
            result = datetime.datetime.strptime(time_string, format_string)
            result = result.replace(
                year=CURRENT_DATE.year,
                month=CURRENT_DATE.month,
                day=CURRENT_DATE.day,
                tzinfo=CURRENT_DATE.tzinfo
            )
            if result < CURRENT_DATE:
                result = result.replace(day=result.day+1)
            break
        except ValueError:
            pass
    return result


def parse_time_delta(time_parts: List[str]) -> Optional[datetime.datetime]:
    result = CURRENT_DATE

    def add_time_part(prop: str, delta: int):
        if prop in found_properties:
            print(f'Duplicated {prop} in time definition: "{" ".join(time_parts)}"')
            sys.exit(1)
        found_properties.append(prop)
        return result + datetime.timedelta(**{prop: delta})

    found_properties: List[str] = []
    for time_part in time_parts:
        try:
            value = int(time_part)
            result = add_time_part('seconds', value)
            continue
        except ValueError:
            pass
        for postfix, property_name in (
                ('h', 'hours'),
                ('m', 'minutes'),
                ('s', 'seconds'),
        ):
            if time_part.lower().endswith(postfix):
                result = add_time_part(property_name, int(
                    time_part.lower().rstrip(postfix)
                ))

    if len(found_properties) != len(time_parts):
        return None
    return result


def write_replace_current_line(text):
    sys.stdout.write(
        f'{(chr(27))}[2K{(chr(27))}[\rb{text} '
    )
    sys.stdout.flush()


def sleep_til_date(target_date: datetime.datetime) -> None:
    time_delta = target_date - CURRENT_DATE
    wait_seconds = time_delta.total_seconds()
    print(f"Gonna wait for {int(wait_seconds)} seconds (til {target_date.strftime('%H:%M:%S')})")
    if DO_COUNTDOWN:
        for seconds_left in range(int(wait_seconds), 0, -1):
            write_replace_current_line(datetime.timedelta(seconds=seconds_left))
            time.sleep(1)
            write_replace_current_line('0:00:00')
        print()
    else:
        time.sleep(wait_seconds)


def main():
    target_date = None
    if len(ARGS) == 1 and ':' in ARGS[0]:
        target_date = parse_exact_time(ARGS[0])
    else:
        target_date = parse_time_delta(ARGS)
    if not target_date:
        print("Can't parse the date/time: \"{' '.join(ARGS)}\'")
        print()
        print_usage()
        sys.exit(1)
    sleep_til_date(target_date)


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\nReceived SIGINT. Cancelling the timer.")
        sys.exit(130)
